// src/components/Commandes/hooks/useAutoSync.js
import { useCallback, useEffect, useRef, useState } from "react";
import { toast } from "react-toastify";
import { CommandeNotificationService } from "../CommandeNotificationService";

export const useAutoSync = ({
  mutateCommandes,
  setSyncStatus,
  setIsSyncing,
}) => {
  const syncIntervalRef = useRef(null);
  const [isAutoSyncActive, setIsAutoSyncActive] = useState(false);
  const [syncInterval, setSyncInterval] = useState(1); // 1 minute par d√©faut

  // Fonction pour v√©rifier les nouvelles commandes et envoyer des notifications
  const checkNewCommandesAndNotify = useCallback(
    async (currentCommandes, previousCommandes) => {
      try {
        // Cr√©er un Set des IDs des commandes pr√©c√©dentes
        const previousIds = new Set(
          previousCommandes.map((cmd) => cmd.externalId)
        );

        // Identifier les nouvelles commandes
        const newCommandes = currentCommandes.filter(
          (cmd) => !previousIds.has(cmd.externalId) && !cmd.commandeNotification
        );

        if (newCommandes.length === 0) {
          console.log("üì≠ Aucune nouvelle commande √† notifier");
          return 0;
        }

        console.log(
          `üì® ${newCommandes.length} nouvelle(s) commande(s) d√©tect√©e(s)`
        );

        let notificationsSent = 0;

        // Envoyer les notifications pour chaque nouvelle commande
        for (const commande of newCommandes) {
          try {
            // Envoyer la notification par email
            await CommandeNotificationService.sendNewCommandeNotification(
              commande
            );

            // Marquer la commande comme notifi√©e
            await CommandeNotificationService.markCommandeNotificationAsSent(
              commande.id
            );

            notificationsSent++;
            console.log(`‚úÖ Notification envoy√©e pour: ${commande.externalId}`);

            // Petit d√©lai entre chaque envoi pour √©viter le spam
            await new Promise((resolve) => setTimeout(resolve, 1000));
          } catch (error) {
            console.error(
              `‚ùå Erreur notification commande ${commande.externalId}:`,
              error
            );
          }
        }

        return notificationsSent;
      } catch (error) {
        console.error(
          "‚ùå Erreur lors de la v√©rification des nouvelles commandes:",
          error
        );
        return 0;
      }
    },
    []
  );

  // Fonction pour synchroniser une plateforme sp√©cifique
  const syncPlatform = useCallback(async (platformName, token) => {
    const endpoints = {
      MEDITLINK: {
        url: `${
          import.meta.env.VITE_API_BASE_URL
        }/meditlink/cases/save?page=0&size=50`,
        method: "POST",
      },
      ITERO: {
        url: `${import.meta.env.VITE_API_BASE_URL}/itero/commandes/save`,
        method: "POST",
      },
      THREESHAPE: {
        url: `${import.meta.env.VITE_API_BASE_URL}/threeshape/cases/save`,
        method: "GET",
      },
      DEXIS: {
        url: `${import.meta.env.VITE_API_BASE_URL}/dexis/commandes`,
        method: "POST",
      },
    };

    const endpoint = endpoints[platformName];
    if (!endpoint) {
      console.warn(`‚ö†Ô∏è Plateforme non configur√©e: ${platformName}`);
      return;
    }

    try {
      const response = await fetch(endpoint.url, {
        method: endpoint.method,
        headers: {
          Authorization: `Bearer ${token}`,
          ...(endpoint.method === "POST" && {
            "Content-Type": "application/json",
          }),
        },
      });

      if (response.ok) {
        console.log(`‚úÖ ${platformName} synchronis√©e`);
        return { success: true, platform: platformName };
      } else {
        console.warn(`‚ö†Ô∏è Erreur ${platformName}: ${response.status}`);
        return {
          success: false,
          platform: platformName,
          error: response.status,
        };
      }
    } catch (error) {
      console.error(`‚ùå Erreur connexion ${platformName}:`, error);
      return { success: false, platform: platformName, error: error.message };
    }
  }, []);

  // Fonction pour synchroniser toutes les plateformes
  const syncAllPlatforms = useCallback(async () => {
    console.log("üîÑ D√©but de la synchronisation automatique...");

    setIsSyncing(true);

    try {
      const token = localStorage.getItem("token");
      if (!token) {
        console.warn("‚ùå Token manquant pour la synchronisation automatique");
        return;
      }

      // R√©cup√©rer l'√©tat actuel des commandes avant la synchronisation
      const responseBefore = await fetch(
        `${import.meta.env.VITE_API_BASE_URL}/public/commandes`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (!responseBefore.ok) {
        throw new Error("Erreur lors de la r√©cup√©ration des commandes");
      }

      const commandesBefore = await responseBefore.json();

      // Synchroniser toutes les plateformes en parall√®le
      const platforms = ["MEDITLINK", "ITERO", "THREESHAPE", "DEXIS"];
      const syncResults = await Promise.allSettled(
        platforms.map((platform) => syncPlatform(platform, token))
      );

      // Analyser les r√©sultats
      const successfulSyncs = syncResults.filter(
        (result) => result.status === "fulfilled" && result.value.success
      ).length;

      console.log(
        `‚úÖ ${successfulSyncs}/${platforms.length} plateformes synchronis√©es avec succ√®s`
      );

      // Attendre un peu pour que les synchronisations se terminent
      await new Promise((resolve) => setTimeout(resolve, 3000));

      // Rafra√Æchir les donn√©es
      await mutateCommandes();

      // R√©cup√©rer les nouvelles commandes apr√®s synchronisation
      const responseAfter = await fetch(
        `${import.meta.env.VITE_API_BASE_URL}/public/commandes`,
        {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        }
      );

      if (!responseAfter.ok) {
        throw new Error(
          "Erreur lors de la r√©cup√©ration des commandes apr√®s sync"
        );
      }

      const commandesAfter = await responseAfter.json();

      // Identifier et notifier les nouvelles commandes
      const notificationsSent = await checkNewCommandesAndNotify(
        commandesAfter,
        commandesBefore
      );

      // Mettre √† jour le statut de synchronisation
      setSyncStatus((prev) => ({
        ...prev,
        AUTO_SYNC: {
          status: "success",
          message: `Sync: ${successfulSyncs}/4 plateformes - ${notificationsSent} nouvelle(s) commande(s)`,
          count: notificationsSent,
          timestamp: new Date().toLocaleTimeString(),
          interval: syncInterval,
        },
      }));

      // Afficher une notification toast si nouvelles commandes
      if (notificationsSent > 0) {
        toast.success(
          `üîÑ ${notificationsSent} nouvelle(s) commande(s) synchronis√©e(s)`,
          {
            position: "top-right",
            autoClose: 5000,
          }
        );
      } else if (successfulSyncs > 0) {
        toast.info(`üîÑ Synchronisation termin√©e - Aucune nouvelle commande`, {
          position: "top-right",
          autoClose: 3000,
        });
      }
    } catch (error) {
      console.error("‚ùå Erreur lors de la synchronisation automatique:", error);

      setSyncStatus((prev) => ({
        ...prev,
        AUTO_SYNC: {
          status: "error",
          message: "Erreur de synchronisation",
          timestamp: new Date().toLocaleTimeString(),
        },
      }));

      toast.error("‚ùå Erreur lors de la synchronisation automatique", {
        position: "top-right",
        autoClose: 5000,
      });
    } finally {
      setIsSyncing(false);
    }
  }, [
    mutateCommandes,
    setSyncStatus,
    setIsSyncing,
    syncPlatform,
    checkNewCommandesAndNotify,
    syncInterval,
  ]);

  // D√©marrer la synchronisation automatique
  const startAutoSync = useCallback(
    (intervalMinutes = null) => {
      // Utiliser l'intervalle fourni ou celui par d√©faut
      const intervalToUse =
        intervalMinutes !== null ? intervalMinutes : syncInterval;

      // Arr√™ter l'intervalle existant
      if (syncIntervalRef.current) {
        clearInterval(syncIntervalRef.current);
      }

      setIsAutoSyncActive(true);

      // D√©marrer imm√©diatement une premi√®re synchronisation
      syncAllPlatforms();

      // Configurer l'intervalle
      const intervalMs = intervalToUse * 60 * 1000;
      syncIntervalRef.current = setInterval(syncAllPlatforms, intervalMs);

      console.log(
        `üîÑ Synchronisation automatique d√©marr√©e (toutes les ${intervalToUse} minutes)`
      );
      toast.success(
        `üîÑ Auto Sync activ√© - Toutes les ${intervalToUse} minutes`,
        {
          position: "top-right",
          autoClose: 3000,
        }
      );
    },
    [syncAllPlatforms, syncInterval]
  );

  // Arr√™ter la synchronisation automatique
  const stopAutoSync = useCallback(() => {
    if (syncIntervalRef.current) {
      clearInterval(syncIntervalRef.current);
      syncIntervalRef.current = null;
      setIsAutoSyncActive(false);
      console.log("‚èπÔ∏è Synchronisation automatique arr√™t√©e");
      toast.info("‚èπÔ∏è Auto Sync d√©sactiv√©", {
        position: "top-right",
        autoClose: 3000,
      });
    }
  }, []);

  // Changer l'intervalle de synchronisation
  const changeSyncInterval = useCallback(
    (newInterval) => {
      if (newInterval < 1 || newInterval > 60) {
        toast.error("‚ùå L'intervalle doit √™tre entre 1 et 60 minutes", {
          position: "top-right",
          autoClose: 5000,
        });
        return;
      }

      setSyncInterval(newInterval);

      // Si l'auto-sync est actif, red√©marrer avec le nouvel intervalle
      if (isAutoSyncActive) {
        startAutoSync(newInterval);
      }

      console.log(
        `‚è±Ô∏è Intervalle de synchronisation chang√© √† ${newInterval} minutes`
      );
      toast.info(`‚è±Ô∏è Intervalle d√©fini √† ${newInterval} minutes`, {
        position: "top-right",
        autoClose: 3000,
      });
    },
    [isAutoSyncActive, startAutoSync]
  );

  // Synchronisation manuelle
  const manualSync = useCallback(() => {
    console.log("üîÑ Synchronisation manuelle d√©clench√©e");
    syncAllPlatforms();
  }, [syncAllPlatforms]);

  // Nettoyer l'intervalle lors du d√©montage
  useEffect(() => {
    return () => {
      if (syncIntervalRef.current) {
        clearInterval(syncIntervalRef.current);
      }
    };
  }, []);

  return {
    startAutoSync,
    stopAutoSync,
    manualSync,
    syncAllPlatforms,
    isAutoSyncActive,
    syncInterval,
    changeSyncInterval,
  };
};

export default useAutoSync;
